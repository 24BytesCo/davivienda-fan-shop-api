/**\n * Pruebas unitarias para AuthService.\n *\n * Objetivo:\n * - Validar creaciÛn de usuarios (normalizaciÛn, duplicados, reglas de rol, hash y sanitizaciÛn).\n * - Validar flujo de login (credenciales v·lidas/ inv·lidas) y emisiÛn de JWT.\n *\n * Notas:\n * - cryptjs se mockea para evitar cÛmputo real de hash y facilitar aserciones.\n * - El repositorio de User y JwtService se simulan con Jest.\n */\nimport { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from './auth.service';
import { getRepositoryToken } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { Repository } from 'typeorm';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcryptjs';
jest.mock('bcryptjs', () => ({
  __esModule: true,
  genSalt: jest.fn().mockResolvedValue('salt'),
  hash: jest.fn().mockResolvedValue('hashed'),
  compare: jest.fn().mockResolvedValue(true),
}));
import { RolesUsuario } from './enum/roles-usuario.enum';

type MockRepo<T = any> = Partial<Record<keyof Repository<T>, jest.Mock>> & {
  create?: jest.Mock;
};

const createUser = (overrides: Partial<User> = {}): User => ({
  id: 'uuid-user',
  email: 'user@example.com',
  password: 'hashed',
  fullName: 'Nombre Apellido',
  role: RolesUsuario.USER,
  createdAt: new Date(),
  deletedAt: null,
  ...overrides,
} as any);

describe('AuthService', () => {
  let service: AuthService;
  let repo: MockRepo<User>;
  let jwt: { signAsync: jest.Mock };

  beforeEach(async () => {
    repo = {
      findOne: jest.fn(),
      save: jest.fn(),
      create: jest.fn(),
    } as any;

    jwt = { signAsync: jest.fn().mockResolvedValue('token-123') };

    // bcryptjs is mocked above; adjust defaults per-test when needed

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        { provide: getRepositoryToken(User), useValue: repo },
        { provide: JwtService, useValue: jwt },
      ],
    }).compile();

    service = module.get(AuthService);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('crea usuario p√∫blico con rol USER y retorna sin password', async () => {
    repo.findOne!.mockResolvedValue(null);
    const toCreate = createUser({ password: undefined as any }) as any;
    repo.create!.mockReturnValue(toCreate);
    repo.save!.mockResolvedValue(createUser());

    const result = await service.create({
      email: 'User@Example.com ',
      password: 'StrongP@ssword#2025',
      fullName: 'Nombre Apellido',
    } as any);

    expect(repo.findOne).toHaveBeenCalledWith({
      where: { email: 'user@example.com' },
    });
    expect(repo.create).toHaveBeenCalled();
    expect(repo.save).toHaveBeenCalled();
    expect(result).toMatchObject({ email: 'user@example.com', role: RolesUsuario.USER });
    expect((result as any).password).toBeUndefined();
  });

  /**\n   * Si el email ya existe, debe lanzar una excepciÛn de conflicto.\n   */\nit('lanza conflicto si email ya existe', async () => {
    repo.findOne!.mockResolvedValue(createUser());
    await expect(
      service.create({ email: 'user@example.com', password: 'x', fullName: 'n' } as any),
    ).rejects.toThrow('El correo ya est√° registrado');
  });

  /**\n   * Cuando el creador es EDITOR, no puede asignar roles distintos de USER.\n   */\nit('EDITOR no puede crear ADMIN', async () => {
    repo.findOne!.mockResolvedValue(null);
    repo.create!.mockReturnValue(createUser());
    repo.save!.mockResolvedValue(createUser());

    await expect(
      service.create({
        email: 'user@example.com',
        password: 'StrongP@ssword#2025',
        fullName: 'Nombre Apellido',
        creatorRole: RolesUsuario.EDITOR,
        role: RolesUsuario.ADMIN,
      } as any),
    ).rejects.toThrow('Un editor solo puede crear usuarios');
  });

  /**\n   * Cuando el creador es ADMIN, puede asignar el rol solicitado (p. ej., EDITOR).\n   */\nit('ADMIN puede crear EDITOR', async () => {
    repo.findOne!.mockResolvedValue(null);
    repo.create!.mockReturnValue(createUser({ role: RolesUsuario.EDITOR }));
    repo.save!.mockResolvedValue(createUser({ role: RolesUsuario.EDITOR }));

    const created = await service.create({
      email: 'user@example.com',
      password: 'StrongP@ssword#2025',
      fullName: 'Nombre Apellido',
      creatorRole: RolesUsuario.ADMIN,
      role: RolesUsuario.EDITOR,
    } as any);

    expect(created.role).toBe(RolesUsuario.EDITOR);
  });

  /**\n   * En login exitoso, retorna token JWT y el usuario sin password.\n   */\nit('login exitoso devuelve token y usuario sanitizado', async () => {
    repo.findOne!.mockResolvedValue(createUser());
    (bcrypt.compare as jest.Mock).mockResolvedValue(true);

    const { user, token } = await service.login({ email: 'user@example.com', password: 'pw' } as any);
    expect(jwt.signAsync).toHaveBeenCalled();
    expect(user.password).toBeUndefined();
    expect(token).toBe('token-123');
  });

  /**\n   * Debe fallar si el usuario no existe para el email dado.\n   */\nit('login falla si usuario no existe', async () => {
    repo.findOne!.mockResolvedValue(null);
    await expect(service.login({ email: 'nobody@example.com', password: 'x' } as any)).rejects.toThrow(
      'Credenciales inv√°lidas',
    );
  });

  /**\n   * Debe fallar si la contraseÒa no coincide.\n   */\nit('login falla si password incorrecto', async () => {
    repo.findOne!.mockResolvedValue(createUser());
    (bcrypt.compare as jest.Mock).mockResolvedValue(false);
    await expect(service.login({ email: 'user@example.com', password: 'bad' } as any)).rejects.toThrow(
      'Credenciales inv√°lidas',
    );
  });
});









